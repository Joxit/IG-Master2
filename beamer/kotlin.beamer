---
title: Introduction à Kotlin
subtitle: Institut Galilée - Master 2 PLS
author: Jones Magloire
date: 22 Septembre 2023
theme: metropolis
toc: true
section-titles: false
filter: code-filter.lua
header-includes: |
  \newcommand{\hideFromPandoc}[1]{#1}
  \usepackage{fourier}
  \hideFromPandoc{ \let\Begin\begin \let\End\end }
  \metroset{block=fill}
  \newcommand{\sectionimage}{Foo}
  \newcommand{\imagedirectory}{kotlin-images}
  \AtBeginEnvironment{block}{\setbeamercolor{itemize item}{fg=jawgMaps}}
  \AtBeginEnvironment{block}{\setbeamercolor{itemize subitem}{fg=jawgMaps}}
  \usepackage{dirtytalk}
  \usepackage{tcolorbox}
  \tcbset{colback=blueGrey!100!jawgMaps,size=small}
  \tcbsetforeverylayer{colframe=jawgMaps!100!black}
build: pandoc -f markdown -st beamer kotlin.beamer -B aboutme.tex -A takima.tex -o kotlin.pdf
---

# Kotlin

---

## Kotlin

### Avantages de Kotlin {.exampleblock}

- Peut être compilé en bytecode pour JVM
- Est interopérable avec Java et Scala
  - Fonctionne dans les projets Java
  - Peut utiliser des libraries Java
  - Peut être exporté en librairie pour des projets Java
- Est sûr (pas de `null`) et moins verbeux

# Les concepts Kotlin

## Les concepts Kotlin

- Programmation Orienté Objet (POO)
- Programmation Fonctionnel (Lambda, fonction anonyme...)
- Typage dynamique
- Immutabilité
- Interopérabilité avec Java
- Null safe

# Écrire du Kotlin

---

## Exemple fonction main Java

```java
class HelloWorld {
  public static void main(String[] args) {
    System.out.println("Hello, World!"); 
  }
}
```

---

## Exemple fonction main Kotlin

```kotlin
fun main(args: Array<String>) {
  println("Hello, world!")
}
```

```kotlin
fun main() {
  println("Hello, world!")
}
```

```kotlin
fun main() = println("Hello, world!")
```

---

## Kotlin VS Java

### Les différences {.exampleblock}
- Tout comme Java, la fonction `main` est le point d'entrée du programme
- Elle prend en argument une liste de `String` qui peut être omis
- `println` affiche à l'écran ce qu'il prend en paramètre avec un saut de ligne
- Pas besoin de mettre le package `System.out` pour effectuer un print sur l'écran

---


## Exemple variables Java

```java
// Affectation immédiate
int a = 1;
```

```java
// Ajouté depuis Java 10 (Mars 2018)
// Le type `int` est déduit par la valeure
var b = 2;
// Et on peut reassigner une variable `var`
b = a;
```

```java
// On peut déclarer une variable et l'affecter après
int c;
c = 3;
```

## Exemple variables Kotlin

```kotlin
// Affectation immédiate
val a: Int = 1
a = 4 // Erreur: Une valeur ne peut être modifiée
```

```kotlin
// Le type `Int` est déduit par la valeure
var b = 2
// Et on peut reassigner une variable `var`
b = a
```

```kotlin
// Le type est requis quand il n'y a pas
// de valeure d'initialisation
val c: Int
// Première initialisation
c = 3
```

## Kotlin vs Java

### Les différences {.exampleblock}
- En Kotlin nous avons la notion d'immutabilité grâce aux `val`
- Les primitives Java ont une majuscule en kotlin (`int` devient `Int`)
- Le type de la variable se met après le nom de celle-ci
- Le type de la variable peut être déduite dans la plupart des cas

## Example functions Java

```java
public int sum(int a, int b) {
  return a + b;
}
```

```java
int mul(int a, int b) {
  return a * b;
}
```

## Example functions Kotlin

```kotlin
// Le mot clé est `fun` et le type se met à la fin
fun sum(a: Int, b: Int): Int {
  return a + b
}
```

```kotlin
// Le type de retour peut être déduit
internal fun mul(a: Int, b: Int) = a * b
```

## Kotlin vs Java

### Les différences {.exampleblock}
- Par défaut tout est `public` en Kotlin
- Pour les functions simples, on peut mettre un `=` avec le retour directement
- Le type se met toujours après les déclarations
- `public` (par défault); `internal` (=> rien en Java); `protected`; `private`

## Example conditions if Java

```java
int maxOf(int a, int b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}
```

```java
int maxOf(int a, int b) {
  // Opérateur ternaire
  return a > b ? a : b;
}
```

## Example conditions Kotlin

```kotlin
fun maxOf(a: Int, b: Int): Int {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}
```

```kotlin
fun maxOf(a: Int, b: Int): Int {
  return if (a > b) a else b
}
// Équivalent à l'opérateur ternaire
fun maxOf(a: Int, b: Int) = if (a > b) a else b
```

## Kotlin vs Java

### Les différences {.exampleblock}
- Le return peut être mis dans le `if` comme en Java ou avant le `if`
- L'opérateur ternaire n'existe pas en Kotlin, c'est un if normal

## Example expressions `switch` Java

```java
// Ancien style switch/case
int switchCase(int x) {
  switch (x) {
    case 1:
    case 3:
      return -1;
    default: return x * 2;
  }
}
```

## Example expressions `switch` Java

```java
// Les expression switch/case
// Ajouté depuis Java 12 (Mars 2019)
int switchCase(int x) {
  return switch (x) {
    case 1, 2 -> -1;
    default -> x * 2;
  };
}
```

## Example expressions `when` Kotlin

```kotlin
fun switchCase(x: Int): Int {
  when (x) {
    1, 2 -> return -1
    else -> return x * 2
  }
}
```

```kotlin
fun switchCase(x: Int): Int = 
  when (x) {
    1, 2 -> -1
    else -> x * 2
  }
```

## Example expressions `when` Kotlin

```kotlin
fun switchCase(x: Int) =
  when {
    x <= 2 -> -1
    x == 3 -> 0
    else -> x * 2
  }
```
## Kotlin vs Java

### Les différences {.exampleblock}
- Le mot clé pour les expression est différente entre Java et Kotlin, nous avons le `switch` et `when`
- Depuis Java 12 les expressions sont plus semblable à Kotlin
- Dans les deux cas on peut combiner plusieurs options qui retournen la même instruction 
- Possibilité de mettre des conditions plus complexes dans les options en Kotlin

## Example boucles `for` Java

```java
List<String> list = Arrays.asList("a", "b", "c", "d");
for (int i = 0; i < list.size(); i++) {
  System.out.println(list.get(i));
}
```

```java
var list = Arrays.asList("a", "b", "c", "d");
for (String elt : list) {
  System.out.println(elt);
}
```

## Example boucles `for` Kotlin

```kotlin
val list = listOf("a", "b", "c", "d")
for (i in 0..list.size - 1) {
  println(list[i])
}
```

```kotlin
val list = listOf("a", "b", "c", "d")
for (elt in list) {
  println(elt)
}
```
```kotlin
val list = listOf("a", "b", "c", "d")
for (i in list.size - 1 downTo 0 step 2) {
  println(list[i])
}
```

## Example boucles `while` et `do/while` Java/Kotlin

```java
var n = 0;
while (n < 0) {
  System.out.println(n);
  n++;
}
```

```java
var n = 0;
do {
  System.out.println(n);
  n++;
} while (n < 0);
```

## Kotlin vs Java

### Les différences {.exampleblock}
- Création de liste plus simple en Kotlin
- Il existe ce qu'on appelle les Ranges dans Kotlin, cela permet à la fois de créer des listes de nombres mais également de gérer les conditions d'arrêt des boucles `for`
- Dans les deux cas il y a la boucle amélioré pour itérer sur les éléments directement à l'aide de `:` en Java et `in` en Kotlin
- Pour le `while` et `do`/`while` c'est exactement la même chose

## Example boucles `forEach` et `map` Java

```java
// Depuis Java 8 (Mars 2014)
var list = Arrays.asList("a", "b", "c", "d")
  .stream()
  .map(elt -> elt + "_" + elt)
  .collect(Collectors.toList());
list.forEach(elt -> System.out.println(elt));
// Equivalent à
list.forEach(System.out::println);
```

```java
// Depuis Java 16 (Mars 2021)
var list = Arrays.asList("a", "b", "c", "d")
  .stream()
  .map(elt -> elt + "_" + elt)
  .toList();
```

## Example boucles `forEach` et `map` Kotlin

```kotlin
val list = listOf("a", "b", "c", "d")
  .map { elt -> elt + "_" + elt }
list.forEach { elt -> println(elt) }
// Equivalent à (où `it` fait référence à
// l'élément de la lambda)
list.forEach { println(it) }
// Equivalent à
list.forEach(::println)
```

## Kotlin vs Java

### Les différences {.exampleblock}
- En Java nous devons passer par des streams traiter des listes d'éléments avec des lambdas 
- Java essaie de rattraper son retard avec l'ajout de `toList()` en 2021
- L'utilisation de la Stream API est très verbeuse en Java
- Dans les deux cas, tout est immutable, vos listes initiales resteront inchangées

## Example POJO avant `record` Java

```java
public class Human {
  private String name;
  private String surname;
  public Human(String name, String surname) {
    this.name = name;
    this.surname = surname;
  }
  public Human(String name) { this.name = name; }
  public String getName() { return name; }
  public String getSurname() { return surname; }
  public String toString() { /* ... */ }
  public int hashcode() { /* ... */ }
  public boolean equals(Object o) { /* ... */ }
}
```

## Example POJO `record` Java

```java
// Depuis Java 14 (Mars 2020)
public record Human(String name, String surname) {
  // Second constructeur
  public Human(String name) {
    this(name, null);
  }
}
```

```java
// Création des objets
var man = new Human("John", "Doe");
var woman = new Human("Jane");
System.out.println(man + " / " + man.name());
// Human[name=John, surname=Doe] / John
System.out.println(woman);
// Human[name=Jane, surname=null]
```

## Example POJO `data class` Kotlin

```kotlin
data class Human(
  val name: String,
  val surname: String
) {
  constructor(name: String) : this(name, "")
}
```

```kotlin
val man = Human("John", "Doe")
val woman = Human("Jane")
println("$man / ${man.name}")
// Human(name=John, surname=Doe) / John
println(woman)
// Human(name=Jane, surname=)
```

## Kotlin vs Java

### Les différences {.exampleblock}
- Les POJO (Plain Old Java Object) sont des objets simples, sans règle métiers. Nous les utilisons pour décrire des tables (on les appelle également Java Bean) ou pour du transfert de donnée (également appelé DTO: Data Transfert Object).
- Java essaie de rattraper son retard avec l'ajout des records en 2020
- Java necessite toujours l'utilisation d'accolades lors de la déclaration de `record`

# Les exclusivités de Kotlin

## Null safety : Safe Calls

```kotlin
val notNullString: String = "Jamais null"
val nullableString: String? = "Peut être null"
val nullString: String? = null

println(notNullString.lowercase())
// -> "jamais null"
// println(nullableString.lowercase())
// -> ne compile pas
println(nullableString?.lowercase())
// -> "peut être null"
println(nullString?.lowercase())
// -> null
```

## Null safety : Elvis Operator `?:`

```kotlin
val nullableString: String? = "Peut être null"
val nullString: String? = null

println(nullableString ?: "C'était null")
// -> "Peut être null"
println(nullString ?: "C'était null")
// -> "C'était null"
```

## Null safety : Unsafe Call

```kotlin
val nullableString: String? = "Peut être null"
val nullString: String? = null

println(nullableString!!)
// -> "Peut être null"
println(nullString!!)
// -> throw une exception `NullPointerException`
```

## String et templates

```kotlin
val s = "Kotlin"
val n = 2011

println("Le language $s a été créé en $n")

println("""En $s
  on peut
  écrire sur
  plusieurs lignes
  """.trimIndent())
```

## TODO / `NotImplementedError`

```kotlin
fun getOrNull(): Any? =
  TODO("Not Implemented yet!")
// -> throw une exception `NotImplementedError`

fun getOrNull(): Any? = { }
// Ne va pas compiler car le retour ne match pas
```

## Conclusion {.standout}

\centering\Huge Question ?
